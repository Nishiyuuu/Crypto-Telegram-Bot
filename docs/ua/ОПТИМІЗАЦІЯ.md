# ‚ö° –û–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—è —Ç–∞ –ø—Ä–æ–¥—É–∫—Ç–∏–≤–Ω—ñ—Å—Ç—å

–ü–æ–≤–Ω–∏–π –≥–∞–π–¥ –ø–æ –æ–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—ó Crypto Monitor Bot –¥–ª—è –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ—ó –ø—Ä–æ–¥—É–∫—Ç–∏–≤–Ω–æ—Å—Ç—ñ —Ç–∞ –µ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—ñ.

## üìã –ó–º—ñ—Å—Ç

- [–ó–∞–≥–∞–ª—å–Ω—ñ –ø—Ä–∏–Ω—Ü–∏–ø–∏](#–∑–∞–≥–∞–ª—å–Ω—ñ-–ø—Ä–∏–Ω—Ü–∏–ø–∏)
- [–û–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—è —Å–µ—Ä–≤–µ—Ä–∞](#–æ–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—è-—Å–µ—Ä–≤–µ—Ä–∞)
- [–û–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—è –±–∞–∑–∏ –¥–∞–Ω–∏—Ö](#–æ–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—è-–±–∞–∑–∏-–¥–∞–Ω–∏—Ö)
- [–ö–µ—à—É–≤–∞–Ω–Ω—è](#–∫–µ—à—É–≤–∞–Ω–Ω—è)
- [API –æ–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—è](#api-–æ–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—è)
- [–ú–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥ –ø—Ä–æ–¥—É–∫—Ç–∏–≤–Ω–æ—Å—Ç—ñ](#–º–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥-–ø—Ä–æ–¥—É–∫—Ç–∏–≤–Ω–æ—Å—Ç—ñ)
- [–°–∫–µ–π–ª—ñ–Ω–≥](#—Å–∫–µ–π–ª—ñ–Ω–≥)
- [Benchmarks](#benchmarks)

## üéØ –ó–∞–≥–∞–ª—å–Ω—ñ –ø—Ä–∏–Ω—Ü–∏–ø–∏

### –û—Å–Ω–æ–≤–Ω—ñ –º–µ—Ç—Ä–∏–∫–∏

| –ú–µ—Ç—Ä–∏–∫–∞ | –¶—ñ–ª—å | –ö—Ä–∏—Ç–∏—á–Ω–æ |
|---------|------|----------|
| –ß–∞—Å –≤—ñ–¥–ø–æ–≤—ñ–¥—ñ | < 500ms | > 2s |
| –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è RAM | < 80% | > 95% |
| CPU –Ω–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è | < 70% | > 90% |
| –î–æ—Å—Ç—É–ø–Ω—ñ—Å—Ç—å | > 99.9% | < 99% |

### –°—Ç—Ä–∞—Ç–µ–≥—ñ—ó –æ–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—ó

1. **Lazy Loading** - –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –¥–∞–Ω–∏—Ö –∑–∞ –ø–æ—Ç—Ä–µ–±–æ—é
2. **Caching** - –∫–µ—à—É–≤–∞–Ω–Ω—è —á–∞—Å—Ç–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞–Ω–∏—Ö –¥–∞–Ω–∏—Ö
3. **Connection Pooling** - –ø–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –∑'—î–¥–Ω–∞–Ω—å
4. **Rate Limiting** - –æ–±–º–µ–∂–µ–Ω–Ω—è —á–∞—Å—Ç–æ—Ç–∏ –∑–∞–ø–∏—Ç—ñ–≤
5. **Compression** - —Å—Ç–∏—Å–Ω–µ–Ω–Ω—è –¥–∞–Ω–∏—Ö

## üñ•Ô∏è –û–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—è —Å–µ—Ä–≤–µ—Ä–∞

### –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è Node.js

```javascript
// package.json - –æ–ø—Ç–∏–º—ñ–∑–æ–≤–∞–Ω—ñ —Å–∫—Ä–∏–ø—Ç–∏
{
  "scripts": {
    "start": "node --max-old-space-size=2048 --optimize-for-size src/bot.js",
    "start:prod": "node --max-old-space-size=4096 --gc-interval=100 src/bot.js"
  }
}
```

### PM2 –æ–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—è

```javascript
// ecosystem.config.js
module.exports = {
  apps: [{
    name: 'crypto-bot',
    script: './src/bot.js',
    instances: 'max', // –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ –≤—Å—ñ —è–¥—Ä–∞
    exec_mode: 'cluster',
    max_memory_restart: '1G',
    node_args: '--max-old-space-size=2048',
    env: {
      NODE_ENV: 'production',
      UV_THREADPOOL_SIZE: 16 // –ó–±—ñ–ª—å—à–∏—Ç–∏ thread pool
    },
    // Graceful restart
    kill_timeout: 5000,
    listen_timeout: 3000,
    
    // –ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–∏–π –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫ –ø—Ä–∏ –≤–∏—Ç—ñ–∫—É –ø–∞–º'—è—Ç—ñ
    max_restarts: 10,
    min_uptime: '10s'
  }]
};
```

### –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è —Å–∏—Å—Ç–µ–º–∏

```bash
# /etc/security/limits.conf
ubuntu soft nofile 65535
ubuntu hard nofile 65535

# /etc/sysctl.conf
net.core.somaxconn = 1024
net.ipv4.tcp_max_syn_backlog = 1024
vm.swappiness = 10
```

### –û–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—è –ø–∞–º'—è—Ç—ñ

```javascript
// src/config/memory.js
const memoryOptimization = {
  // –û—á–∏—â–µ–Ω–Ω—è –ø–∞–º'—è—Ç—ñ –∫–æ–∂–Ω—ñ 30 —Ö–≤–∏–ª–∏–Ω
  clearMemory: () => {
    if (global.gc) {
      global.gc();
    }
  },
  
  // –ú–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è –ø–∞–º'—è—Ç—ñ
  memoryUsage: () => {
    const used = process.memoryUsage();
    return {
      rss: Math.round(used.rss / 1024 / 1024 * 100) / 100,
      heapTotal: Math.round(used.heapTotal / 1024 / 1024 * 100) / 100,
      heapUsed: Math.round(used.heapUsed / 1024 / 1024 * 100) / 100,
      external: Math.round(used.external / 1024 / 1024 * 100) / 100
    };
  }
};

// –ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–µ –æ—á–∏—â–µ–Ω–Ω—è
setInterval(memoryOptimization.clearMemory, 30 * 60 * 1000);

module.exports = memoryOptimization;
```

## üóÑÔ∏è –û–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—è –±–∞–∑–∏ –¥–∞–Ω–∏—Ö

### MongoDB –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è

```javascript
// config/database.js
const mongoOptions = {
  // Connection pooling
  maxPoolSize: 10,
  minPoolSize: 2,
  
  // Timeouts
  serverSelectionTimeoutMS: 5000,
  socketTimeoutMS: 45000,
  
  // Buffering
  bufferMaxEntries: 0,
  bufferCommands: false,
  
  // Compression
  compressors: ['zlib'],
  zlibCompressionLevel: 6
};
```

### –Ü–Ω–¥–µ–∫—Å–∞—Ü—ñ—è

```javascript
// scripts/createIndexes.js
const createIndexes = async () => {
  const db = await mongoose.connection.db;
  
  // –Ü–Ω–¥–µ–∫—Å–∏ –¥–ª—è –∫–æ–ª–µ–∫—Ü—ñ—ó users
  await db.collection('users').createIndex({ telegramId: 1 }, { unique: true });
  await db.collection('users').createIndex({ createdAt: 1 });
  await db.collection('users').createIndex({ isActive: 1 });
  
  // –Ü–Ω–¥–µ–∫—Å–∏ –¥–ª—è –∫–æ–ª–µ–∫—Ü—ñ—ó monitoring
  await db.collection('monitoring').createIndex({ userId: 1, symbol: 1 });
  await db.collection('monitoring').createIndex({ updatedAt: 1 });
  
  // –ö–æ–º–ø–æ–∑–∏—Ç–Ω—ñ —ñ–Ω–¥–µ–∫—Å–∏
  await db.collection('pricehistory').createIndex({ 
    symbol: 1, 
    timestamp: -1 
  });
  
  console.log('Indexes created successfully');
};
```

### –û–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—è –∑–∞–ø–∏—Ç—ñ–≤

```javascript
// –ü–æ–≥–∞–Ω–∏–π –∑–∞–ø–∏—Ç
const users = await User.find({});

// –•–æ—Ä–æ—à–∏–π –∑–∞–ø–∏—Ç –∑ –ø—Ä–æ–µ–∫—Ü—ñ—î—é —Ç–∞ –ª—ñ–º—ñ—Ç–æ–º
const users = await User.find({}, 'telegramId username isActive')
  .limit(100)
  .lean(); // –ü–æ–≤–µ—Ä—Ç–∞—î –∑–≤–∏—á–∞–π–Ω—ñ –æ–±'—î–∫—Ç–∏ –∑–∞–º—ñ—Å—Ç—å Mongoose –¥–æ–∫—É–º–µ–Ω—Ç—ñ–≤

// Aggregate –¥–ª—è —Å–∫–ª–∞–¥–Ω–∏—Ö –∑–∞–ø–∏—Ç—ñ–≤
const stats = await User.aggregate([
  { $match: { isActive: true } },
  { $group: { 
    _id: '$subscription', 
    count: { $sum: 1 },
    totalRevenue: { $sum: '$monthlyFee' }
  }},
  { $sort: { count: -1 } }
]);
```

### Cleanup —Å—Ç–∞—Ä–∏—Ö –¥–∞–Ω–∏—Ö

```javascript
// scripts/cleanup.js
const cleanup = async () => {
  const oneWeekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
  
  // –í–∏–¥–∞–ª–µ–Ω–Ω—è —Å—Ç–∞—Ä–∏—Ö –ª–æ–≥—ñ–≤
  await LogEntry.deleteMany({ 
    createdAt: { $lt: oneWeekAgo },
    level: { $in: ['debug', 'info'] }
  });
  
  // –í–∏–¥–∞–ª–µ–Ω–Ω—è –Ω–µ–∞–∫—Ç–∏–≤–Ω–∏—Ö —Å–µ—Å—ñ–π
  await Session.deleteMany({
    lastActivity: { $lt: oneWeekAgo }
  });
  
  console.log('Cleanup completed');
};

// –ó–∞–ø—É—Å–∫ cleanup —â–æ–¥–Ω—è
setInterval(cleanup, 24 * 60 * 60 * 1000);
```

## üöÄ –ö–µ—à—É–≤–∞–Ω–Ω—è

### Redis —ñ–º–ø–ª–µ–º–µ–Ω—Ç–∞—Ü—ñ—è

```javascript
// src/cache/redis.js
const redis = require('redis');
const client = redis.createClient({
  host: process.env.REDIS_HOST || 'localhost',
  port: process.env.REDIS_PORT || 6379,
  password: process.env.REDIS_PASSWORD,
  db: 0,
  
  // Connection pooling
  lazyConnect: true,
  maxRetriesPerRequest: 3,
  retryDelayOnFailover: 100,
  
  // Performance tuning
  enableReadyCheck: false,
  maxRetriesPerRequest: null
});

const cache = {
  // –ö–µ—à—É–≤–∞–Ω–Ω—è –∑ TTL
  set: async (key, value, ttl = 300) => {
    await client.setex(key, ttl, JSON.stringify(value));
  },
  
  get: async (key) => {
    const result = await client.get(key);
    return result ? JSON.parse(result) : null;
  },
  
  // –ö–µ—à—É–≤–∞–Ω–Ω—è –∑ —Ç–µ–≥–∞–º–∏ –¥–ª—è –≥—Ä—É–ø–æ–≤–æ–≥–æ –≤–∏–¥–∞–ª–µ–Ω–Ω—è
  setWithTags: async (key, value, tags, ttl = 300) => {
    await client.setex(key, ttl, JSON.stringify(value));
    for (const tag of tags) {
      await client.sadd(`tag:${tag}`, key);
      await client.expire(`tag:${tag}`, ttl);
    }
  },
  
  // –í–∏–¥–∞–ª–µ–Ω–Ω—è –∑–∞ —Ç–µ–≥–æ–º
  deleteByTag: async (tag) => {
    const keys = await client.smembers(`tag:${tag}`);
    if (keys.length > 0) {
      await client.del(...keys);
    }
    await client.del(`tag:${tag}`);
  }
};

module.exports = cache;
```

### –°—Ç—Ä–∞—Ç–µ–≥—ñ—ó –∫–µ—à—É–≤–∞–Ω–Ω—è

```javascript
// src/services/priceService.js
const getPriceWithCache = async (symbol) => {
  const cacheKey = `price:${symbol}`;
  
  // –°–ø—Ä–æ–±–∞ –æ—Ç—Ä–∏–º–∞—Ç–∏ –∑ –∫–µ—à—É
  let price = await cache.get(cacheKey);
  
  if (!price) {
    // –Ø–∫—â–æ –≤ –∫–µ—à—ñ –Ω–µ–º–∞—î - –∑–∞–ø–∏—Ç –¥–æ API
    price = await fetchPriceFromAPI(symbol);
    
    // –ö–µ—à—É–≤–∞–Ω–Ω—è –Ω–∞ 1 —Ö–≤–∏–ª–∏–Ω—É
    await cache.setWithTags(
      cacheKey, 
      price, 
      ['prices', `price:${symbol}`], 
      60
    );
  }
  
  return price;
};

// Warming up cache
const warmupCache = async () => {
  const popularCoins = ['BTC', 'ETH', 'BNB', 'ADA', 'DOT'];
  
  await Promise.all(
    popularCoins.map(coin => getPriceWithCache(coin))
  );
};
```

### Memory cache –¥–ª—è —á–∞—Å—Ç–∏—Ö –∑–∞–ø–∏—Ç—ñ–≤

```javascript
// src/cache/memory.js
class MemoryCache {
  constructor(maxSize = 1000, ttl = 300000) {
    this.cache = new Map();
    this.maxSize = maxSize;
    this.ttl = ttl;
  }
  
  set(key, value) {
    // LRU eviction
    if (this.cache.size >= this.maxSize) {
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
    
    this.cache.set(key, {
      value,
      timestamp: Date.now()
    });
  }
  
  get(key) {
    const item = this.cache.get(key);
    
    if (!item) return null;
    
    // –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ TTL
    if (Date.now() - item.timestamp > this.ttl) {
      this.cache.delete(key);
      return null;
    }
    
    return item.value;
  }
  
  clear() {
    this.cache.clear();
  }
}

const memoryCache = new MemoryCache(500, 60000); // 500 items, 1 min TTL
module.exports = memoryCache;
```

## üîå API –æ–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—è

### Rate Limiting

```javascript
// src/middleware/rateLimit.js
const rateLimit = require('express-rate-limit');

const apiLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 —Ö–≤–∏–ª–∏–Ω
  max: 100, // –º–∞–∫—Å–∏–º—É–º 100 –∑–∞–ø–∏—Ç—ñ–≤
  message: '–ó–∞–Ω–∞–¥—Ç–æ –±–∞–≥–∞—Ç–æ –∑–∞–ø–∏—Ç—ñ–≤, —Å–ø—Ä–æ–±—É–π—Ç–µ –ø—ñ–∑–Ω—ñ—à–µ',
  standardHeaders: true,
  legacyHeaders: false,
  
  // –î–∏—Ñ–µ—Ä–µ–Ω—Ü—ñ–π–æ–≤–∞–Ω—ñ –ª—ñ–º—ñ—Ç–∏
  skip: (req) => {
    // VIP –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—ñ –º–∞—é—Ç—å –±—ñ–ª—å—à—ñ –ª—ñ–º—ñ—Ç–∏
    return req.user && req.user.subscription === 'premium';
  }
});

// –°–ø–µ—Ü–∏—Ñ—ñ—á–Ω—ñ –ª—ñ–º—ñ—Ç–∏ –¥–ª—è —Ä—ñ–∑–Ω–∏—Ö –µ–Ω–¥–ø–æ—ñ–Ω—Ç—ñ–≤
const strictLimiter = rateLimit({
  windowMs: 60 * 1000, // 1 —Ö–≤–∏–ª–∏–Ω–∞
  max: 5, // –º–∞–∫—Å–∏–º—É–º 5 –∑–∞–ø–∏—Ç—ñ–≤
  skipSuccessfulRequests: true
});

module.exports = { apiLimiter, strictLimiter };
```

### Batch requests

```javascript
// src/services/batchService.js
class BatchService {
  constructor() {
    this.batches = new Map();
    this.batchSize = 50;
    this.batchTimeout = 100; // ms
  }
  
  async addToBatch(type, data) {
    if (!this.batches.has(type)) {
      this.batches.set(type, []);
      
      // –ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–µ –≤–∏–∫–æ–Ω–∞–Ω–Ω—è batch —á–µ—Ä–µ–∑ timeout
      setTimeout(() => this.processBatch(type), this.batchTimeout);
    }
    
    const batch = this.batches.get(type);
    batch.push(data);
    
    // –í–∏–∫–æ–Ω–∞—Ç–∏ batch —è–∫—â–æ –¥–æ—Å—è–≥–Ω—É—Ç–æ —Ä–æ–∑–º—ñ—Ä
    if (batch.length >= this.batchSize) {
      await this.processBatch(type);
    }
  }
  
  async processBatch(type) {
    const batch = this.batches.get(type);
    if (!batch || batch.length === 0) return;
    
    this.batches.delete(type);
    
    try {
      switch (type) {
        case 'price_updates':
          await this.batchUpdatePrices(batch);
          break;
        case 'notifications':
          await this.batchSendNotifications(batch);
          break;
      }
    } catch (error) {
      console.error(`Batch processing error for ${type}:`, error);
    }
  }
  
  async batchUpdatePrices(updates) {
    // –ì—Ä—É–ø—É–≤–∞–Ω–Ω—è –ø–æ —Å–∏–º–≤–æ–ª–∞—Ö
    const grouped = updates.reduce((acc, update) => {
      if (!acc[update.symbol]) acc[update.symbol] = [];
      acc[update.symbol].push(update);
      return acc;
    }, {});
    
    // –û–¥–∏–Ω –∑–∞–ø–∏—Ç –¥–ª—è –∫–æ–∂–Ω–æ–≥–æ —Å–∏–º–≤–æ–ª–∞
    await Promise.all(
      Object.entries(grouped).map(([symbol, data]) => 
        this.updatePriceInDB(symbol, data)
      )
    );
  }
}

const batchService = new BatchService();
module.exports = batchService;
```

### Request deduplication

```javascript
// src/middleware/deduplication.js
class RequestDeduplicator {
  constructor() {
    this.pendingRequests = new Map();
  }
  
  async deduplicate(key, requestFn) {
    if (this.pendingRequests.has(key)) {
      // –ü–æ–≤–µ—Ä–Ω—É—Ç–∏ —ñ—Å–Ω—É—é—á–∏–π –ø—Ä–æ–º—ñ—Å
      return this.pendingRequests.get(key);
    }
    
    const promise = requestFn().finally(() => {
      // –í–∏–¥–∞–ª–∏—Ç–∏ –∑ pending –ø—ñ—Å–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—è
      this.pendingRequests.delete(key);
    });
    
    this.pendingRequests.set(key, promise);
    return promise;
  }
}

const deduplicator = new RequestDeduplicator();

// –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è
const getPrice = async (symbol) => {
  return deduplicator.deduplicate(`price:${symbol}`, async () => {
    return await api.getPrice(symbol);
  });
};
```

## üìä –ú–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥ –ø—Ä–æ–¥—É–∫—Ç–∏–≤–Ω–æ—Å—Ç—ñ

### Metrics –∑–±–∏—Ä–∞–Ω–Ω—è

```javascript
// src/monitoring/metrics.js
const client = require('prom-client');

// –°—Ç–≤–æ—Ä–µ–Ω–Ω—è –º–µ—Ç—Ä–∏–∫
const httpRequestDuration = new client.Histogram({
  name: 'http_request_duration_seconds',
  help: 'Duration of HTTP requests in seconds',
  labelNames: ['method', 'route', 'status_code']
});

const activeUsers = new client.Gauge({
  name: 'active_users_total',
  help: 'Total number of active users'
});

const apiRequestsTotal = new client.Counter({
  name: 'api_requests_total',
  help: 'Total number of API requests',
  labelNames: ['endpoint', 'status']
});

// Middleware –¥–ª—è –∑–±–∏—Ä–∞–Ω–Ω—è –º–µ—Ç—Ä–∏–∫
const metricsMiddleware = (req, res, next) => {
  const start = Date.now();
  
  res.on('finish', () => {
    const duration = (Date.now() - start) / 1000;
    httpRequestDuration
      .labels(req.method, req.route?.path || req.path, res.statusCode)
      .observe(duration);
  });
  
  next();
};

module.exports = {
  httpRequestDuration,
  activeUsers,
  apiRequestsTotal,
  metricsMiddleware,
  register: client.register
};
```

### Performance –ø—Ä–æ—Ñ—ñ–ª—é–≤–∞–Ω–Ω—è

```javascript
// src/utils/profiler.js
class Profiler {
  static async profile(name, fn) {
    const start = process.hrtime.bigint();
    
    try {
      const result = await fn();
      const end = process.hrtime.bigint();
      const duration = Number(end - start) / 1000000; // ms
      
      console.log(`‚è±Ô∏è  ${name}: ${duration.toFixed(2)}ms`);
      
      // –ó–∞–ø–∏—Å–∞—Ç–∏ –≤ –º–µ—Ç—Ä–∏—Ü—ñ
      if (duration > 1000) {
        console.warn(`üêå Slow operation detected: ${name} took ${duration}ms`);
      }
      
      return result;
    } catch (error) {
      const end = process.hrtime.bigint();
      const duration = Number(end - start) / 1000000;
      console.error(`‚ùå ${name} failed after ${duration.toFixed(2)}ms:`, error.message);
      throw error;
    }
  }
  
  static startTimer(name) {
    const start = process.hrtime.bigint();
    return () => {
      const end = process.hrtime.bigint();
      const duration = Number(end - start) / 1000000;
      console.log(`‚è±Ô∏è  ${name}: ${duration.toFixed(2)}ms`);
      return duration;
    };
  }
}

// –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è
const result = await Profiler.profile('Database Query', async () => {
  return await User.find({ isActive: true });
});

const timer = Profiler.startTimer('API Request');
const data = await api.getPrice('BTC');
timer();
```

### Health checks

```javascript
// src/health/healthCheck.js
const healthChecks = {
  database: async () => {
    try {
      await mongoose.connection.db.admin().ping();
      return { status: 'healthy', latency: Date.now() };
    } catch (error) {
      return { status: 'unhealthy', error: error.message };
    }
  },
  
  redis: async () => {
    try {
      const start = Date.now();
      await redis.ping();
      return { status: 'healthy', latency: Date.now() - start };
    } catch (error) {
      return { status: 'unhealthy', error: error.message };
    }
  },
  
  externalAPIs: async () => {
    const results = {};
    
    for (const api of ['coinmarketcap', 'coingecko']) {
      try {
        const start = Date.now();
        await testAPIConnection(api);
        results[api] = { 
          status: 'healthy', 
          latency: Date.now() - start 
        };
      } catch (error) {
        results[api] = { 
          status: 'unhealthy', 
          error: error.message 
        };
      }
    }
    
    return results;
  }
};

module.exports = healthChecks;
```

## üìà –°–∫–µ–π–ª—ñ–Ω–≥

### Horizontal scaling

```javascript
// Load balancer –∫–æ–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ñ—è (nginx)
upstream crypto_bot {
    least_conn;
    server 127.0.0.1:3001 weight=3 max_fails=3 fail_timeout=30s;
    server 127.0.0.1:3002 weight=3 max_fails=3 fail_timeout=30s;
    server 127.0.0.1:3003 weight=2 max_fails=3 fail_timeout=30s;
}

server {
    listen 80;
    location / {
        proxy_pass http://crypto_bot;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        
        # Session affinity
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_connect_timeout 30s;
        proxy_send_timeout 30s;
        proxy_read_timeout 30s;
    }
}
```

### Microservices –∞—Ä—Ö—ñ—Ç–µ–∫—Ç—É—Ä–∞

```javascript
// docker-compose.scale.yml
version: '3.8'
services:
  bot-api:
    build: .
    ports:
      - "3001-3003:3000"
    environment:
      - SERVICE_NAME=api
    depends_on:
      - mongodb
      - redis
    deploy:
      replicas: 3
  
  bot-worker:
    build: .
    command: node src/worker.js
    environment:
      - SERVICE_NAME=worker
    depends_on:
      - mongodb
      - redis
    deploy:
      replicas: 2
  
  bot-scheduler:
    build: .
    command: node src/scheduler.js
    environment:
      - SERVICE_NAME=scheduler
    depends_on:
      - mongodb
      - redis
    deploy:
      replicas: 1
```

### Database sharding

```javascript
// config/sharding.js
const shardingConfig = {
  shards: [
    { host: 'mongo-shard1:27017', database: 'cryptobot_shard1' },
    { host: 'mongo-shard2:27017', database: 'cryptobot_shard2' },
    { host: 'mongo-shard3:27017', database: 'cryptobot_shard3' }
  ],
  
  // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –≤–∏–∑–Ω–∞—á–µ–Ω–Ω—è —à–∞—Ä–¥—É –ø–æ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—É
  getShardForUser: (userId) => {
    const hash = require('crypto')
      .createHash('md5')
      .update(userId.toString())
      .digest('hex');
    const shardIndex = parseInt(hash.substring(0, 8), 16) % shardingConfig.shards.length;
    return shardingConfig.shards[shardIndex];
  }
};

module.exports = shardingConfig;
```

## üìê Benchmarks

### Performance —Ç–µ—Å—Ç–∏

```javascript
// tests/performance/benchmark.js
const Benchmark = require('benchmark');

const suite = new Benchmark.Suite;

// –¢–µ—Å—Ç —à–≤–∏–¥–∫–æ—Å—Ç—ñ –æ–±—Ä–æ–±–∫–∏ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω—å
suite.add('Message Processing', async () => {
  await processMessage({
    chat: { id: 12345 },
    text: '/price BTC'
  });
})

// –¢–µ—Å—Ç —à–≤–∏–¥–∫–æ—Å—Ç—ñ –∑–∞–ø–∏—Ç—ñ–≤ –¥–æ –±–∞–∑–∏
.add('Database Query', async () => {
  await User.findOne({ telegramId: 12345 });
})

// –¢–µ—Å—Ç —à–≤–∏–¥–∫–æ—Å—Ç—ñ API –∑–∞–ø–∏—Ç—ñ–≤
.add('API Request', async () => {
  await api.getPrice('BTC');
})

.on('cycle', function(event) {
  console.log(String(event.target));
})

.on('complete', function() {
  console.log('Fastest is ' + this.filter('fastest').map('name'));
})

.run({ 'async': true });
```

### Load testing

```bash
# artillery.yml
config:
  target: 'http://localhost:3000'
  phases:
    - duration: 60
      arrivalRate: 10
    - duration: 120
      arrivalRate: 50
    - duration: 60
      arrivalRate: 100

scenarios:
  - name: "Price requests"
    weight: 70
    requests:
      - get:
          url: "/api/price/BTC"
  
  - name: "Monitoring operations"
    weight: 30
    requests:
      - post:
          url: "/api/monitoring/add"
          json:
            symbol: "ETH"
            threshold: 5.0

# –ó–∞–ø—É—Å–∫ —Ç–µ—Å—Ç—É
artillery run artillery.yml
```

### Memory leak —Ç–µ—Å—Ç—É–≤–∞–Ω–Ω—è

```javascript
// tests/memory/leak-test.js
const memwatch = require('node-memwatch');

let baseline;

memwatch.on('leak', (info) => {
  console.error('Memory leak detected:', info);
});

memwatch.on('stats', (stats) => {
  console.log('GC stats:', stats);
});

// –ó–∞–ø—É—Å–∫ —Ç–µ—Å—Ç—É –Ω–∞ –≤–∏—Ç—ñ–∫ –ø–∞–º'—è—Ç—ñ
const runLeakTest = async () => {
  // Baseline
  memwatch.gc();
  baseline = memwatch.diff();
  
  // –°–∏–º—É–ª—è—Ü—ñ—è –Ω–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è
  for (let i = 0; i < 10000; i++) {
    await processMessage({
      chat: { id: Math.random() * 100000 },
      text: '/price BTC'
    });
  }
  
  // –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ —Ä—ñ–∑–Ω–∏—Ü—ñ
  const diff = memwatch.diff(baseline);
  console.log('Memory diff:', diff);
  
  if (diff.change.size_bytes > 50 * 1024 * 1024) { // 50MB
    console.error('Potential memory leak detected!');
  }
};

module.exports = runLeakTest;
```

---

**–°—Ç–≤–æ—Ä–µ–Ω–æ –∑ ‚ù§Ô∏è –¥–ª—è —É–∫—Ä–∞—ó–Ω—Å—å–∫–æ—ó –∫—Ä–∏–ø—Ç–æ—Å–ø—ñ–ª—å–Ω–æ—Ç–∏**
